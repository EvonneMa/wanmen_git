第九次课	哈希表																					 ______________				  				 ___________________________
	1.原理：哈希表首先是一个数组array		=========>		key------>|___哈希函数___|--->hashcode--->|___对array的大小size取余___|------>用于array的index
	2.python中,mutable的数据结构都不能作为哈希表(dict)的key
		==> 会导致：1.数据丢失;2.数据垃圾
		==> 如果将自定义类型的对象当做key使用,则该对象一定不能进行修改(虽然可以修改),否则也会造成上述问题
	3.对input进行的变换成为哈希函数hash function(比如Horner's Rule ==> 31x+y rule)
	  得到的数称为哈希码hashcode
	4.hash冲突：产生相同的hashcode或相同的Index
		解决方法：
			1.i)open addressing1：如果发生哈希冲突,则顺次向下连续放置(O(1) -> O(n))
				 线性查找
				 问题：primary clustering(鸠占鹊巢)
				 解决方法：open addressing2
			  ii)open addressing2：如果发生哈希冲突,则依次存放在地址偏移0、1、4、9、16等(n^2)的内存地址处
			     平方查找,解决了primary clustering
			     问题：secondary clustering(地址循环,当i^2大于size时一旦取余就会回到开头发生重复)
			     解决方法：将size尽量取为质数,这样可以保证在(size+1)//2的次数内不会发生index循环。对于一个有效地hash function而言,这个问题不会太严重
			  *python
			2.separate chain：在哈希表的每个地址存放一个链表头指针,元素都放在链表里
			  *java
	5.load factor(λ)――负荷率(负荷率越大,效率越低。通过降低λ使得查询操作时间复杂度维持在O(1))
		如果当前哈希表的大小已经被填满一定比例λ(已放入元素个数/哈希表大小)时,哈希表翻倍
		*python -> 2/3
		 java   -> 0.5、0.75
		当哈希表翻倍后,由于size发生改变,每一个key的hashcode都需要再次计算,称为再哈希Rehash
	6.实现__eq__()来判断相同哈希值的元素是否真正相同
	7.如何使得哈希函数能够均匀(等概率)地分配地址给每一个key
	8.如果只放入k而不放入<k,v>,就成为了set
	9.了解一下python内置的相关模块***
	10.哈希表常用于计数、重复、唯一等问题