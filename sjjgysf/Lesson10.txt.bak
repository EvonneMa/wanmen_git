第十次课	树(与分治+递归关系密切)
	1.二叉搜索树(BST)：对于每一个节点,左边的所有节点值都小于该节点,右边的所有节点值都大于该节点
		i)搜索tar：如果tar大于当前值,向右边去找;否则向左边去找
		ii)插入tar：与搜索相同,遇到None就生成新节点并返回
		iii)删除tar：如果没找到返回None;如果tar节点孩子个数少于2,左子树为空返回右子树、左子树不为空右子树为空返回左子树;
				****  	 如果左右子树都存在,找到左子树的最大值或右子树的最小值,以该值替换并且删掉该最值节点
								 总结：子女个数少于2则直接替换tar节点,子女个数等于2则tar节点不能动
		iv)前序、后序、中序(顺序)遍历
		v)找到最大或最小元素
	2.AVL树(包括红黑树RB树)：通过树的旋转(旋转策略如下)来保证每个节点左右子树的深度差<1,从而使得增删改查操作的时间复杂度保持在O(lgn)
					 								 LR->LL->Balance
					 								 RL->RR->Balance
	3.练习：1.树的大小 左 + 右 + 1
			2.树的深度 max(左,右) + 1
			3.是否为平衡树 找到最大深度、找到最小深度、比较二者的差是否 > 1(递归调用,每次返回一个(最大值,最小值))
			4.floor and ceil**
			5.镜像树
			6.相同树
			7.折叠树
			*以上采用递归方法
			*以下采用循环方法
			8.添加元素、查询元素
			9.BST Sort
			10.中序遍历BST(利用stack)
			11.逐层遍历(自顶向下和自底向上,比较简单)