第九次课	哈希表																					     ______________				  				 ___________________________
	1.原理：哈希表首先是一个数组array		=========>		key------>|___哈希函数___|--->hashcode--->|___对array的大小size取余___|------>用于array的index
	2.python中,mutable的数据结构都不能作为哈希表(dict)的key
		==> 会导致：1.数据丢失;2.数据垃圾
		==> 如果将自定义类型的对象当做key使用,则该对象一定不能进行修改(虽然可以修改),否则也会造成上述问题
	3.对input进行的变换成为哈希函数hash function(比如Horner's Rule ==> 31x+y rule)
	  得到的数称为哈希码hashcode
	4.hash冲突：产生相同的hashcode或相同的Index
		解决方法：
			1.i)open addressing1：如果发生哈希冲突,则顺次向下连续放置(O(1) -> O(n))
				 线性查找
				 问题：primary clustering(鸠占鹊巢)
				 解决方法：open addressing2
			  ii)open addressing2：如果发生哈希冲突,则依次存放在地址偏移0、1、4、9、16等(n^2)的内存地址处
			     平方查找,解决了primary clustering
			     问题：secondary clustering(地址循环,当i^2大于size时一旦取余就会回到开头发生重复)
			     解决方法：将size尽量取为质数,这样可以保证在(size+1)//2的次数内不会发生index循环。对于一个有效地hash function而言,这个问题不会太严重
			  *python
			2.separate chain：在哈希表的每个地址存放一个链表头指针,元素都放在链表里
			  *java
	5.load factor(λ)――负荷率(负荷率越大,效率越低。通过降低λ使得查询操作时间复杂度维持在O(1))
		如果当前哈希表的大小已经被填满一定比例λ(已放入元素个数/哈希表大小)时,哈希表翻倍
		*python -> 2/3
		 java   -> 0.5、0.75
		当哈希表翻倍后,由于size发生改变,每一个key的hashcode都需要再次计算,称为再哈希Rehash
	6.实现__eq__()来判断相同哈希值的元素是否真正相同
	7.如何使得哈希函数能够均匀(等概率)地分配地址给每一个key
	8.如果只放入k而不放入<k,v>,就成为了set
	9.了解一下python内置的相关模块***
	10.哈希表常用于计数、重复、唯一、是否存在、映射等问题
	11.平面上有n个点,求过点数目最多的直线***
	12.LRU：字典+双向链表
	*注意点：1.采用open addressing处理hash冲突时,如删除一个元素需要设置FLAG表示后续是否还有元素
					 2.采用separate chain处理hash冲突,在实现LRU时需多设置一个指针,一个表示冲突、一个表示先后顺序.在删除某个元素时需要同时考虑两个方向