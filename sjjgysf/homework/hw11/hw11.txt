1.数组中第k大的元素	O(nlgk)
	可以用快速排序解决(比heapq快),也可以用堆解决,且堆的大小为k即可
2.频率出现次数最高的前k个单词	O(nlgk)
	当需要多个排序条件时(如先考虑次数,相同时考虑字母表顺序),此时应当考虑自定义类型
3.丑数
	1.判断一个数是否是丑数
	2.找到第k个丑数,每次取出最小的数(需要堆),分别乘以2、3、5再放进去;遇到重复则跳过
4.寻找和最小的前k个组合***
	a、b两个数组,各取一个表示组合
5.合并k个有序链表
	可以采用分治算法O(nlgk);也可以使用堆――当指针不够用的时候,换一个思路(每一次比较是O(lgk),故总共为O(nlgk))
6.寻找中位数,未知长度的数据流
	两种方法：两个链表或两个堆(两个堆还是快啊),一个记录较大值,一个记录较小值
7.IPO
	先排序,然后建立一个堆,里面放所有可行解